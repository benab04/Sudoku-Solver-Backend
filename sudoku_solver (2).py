# -*- coding: utf-8 -*-
"""Sudoku solver.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t5DjKWGwyIh4d8d3Rou5OKaOmAijvmps
"""


# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
# %matplotlib inline
# import matplotlib.pyplot as # plt
import os, random
import cv2
from glob import glob
import sklearn
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow import keras
from keras_preprocessing.image import ImageDataGenerator
from keras.preprocessing.image import load_img
from keras.utils import to_categorical
from keras.models import Sequential
from keras.layers import Activation, Dropout, Dense, Flatten, BatchNormalization, Conv2D, MaxPooling2D
from keras.optimizers import RMSprop
from keras import backend as K
from keras.preprocessing import image
from keras.models import load_model
from sklearn.metrics import accuracy_score, classification_report
from pathlib import Path
from PIL import Image

folder="sudoku"
a=random.choice(os.listdir(folder))
print(a)
sudoku_a = cv2.imread(folder+'/'+a)
# plt.figure()
# plt.imshow(sudoku_a)
# plt.show()

sudoku_a = cv2.resize(sudoku_a, (450,450))
# function to greyscale, blur and change the receptive threshold of image
def preprocess(image):
  gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  blur = cv2.GaussianBlur(gray, (3,3),6)
      #blur = cv2.bilateralFilter(gray,9,75,75)
  threshold_img = cv2.adaptiveThreshold(blur,255,1,1,11,2)
  return threshold_img
threshold = preprocess(sudoku_a)
#let's look at what we have got
# plt.figure()
# plt.imshow(threshold)
# plt.show()

# Finding the outline of the sudoku puzzle in the image
contour_1 = sudoku_a.copy()
contour_2 = sudoku_a.copy()
contour, hierarchy = cv2.findContours(threshold,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(contour_1, contour,-1,(0,255,0),3)
#let's see what we got
# plt.figure()
# plt.imshow(contour_1)
# plt.show()

def main_outline(contour):
  biggest = np.array([])
  max_area = 0
  for i in contour:
    area = cv2.contourArea(i)
    if area >50:
      peri = cv2.arcLength(i, True)
      approx = cv2.approxPolyDP(i , 0.02* peri, True)
      if area > max_area and len(approx) ==4:
          biggest = approx
          max_area = area
  return biggest ,max_area
def reframe(points):
    points = points.reshape((4, 2))
    points_new = np.zeros((4,1,2),dtype = np.int32)
    add = points.sum(1)
    points_new[0] = points[np.argmin(add)]
    points_new[3] = points[np.argmax(add)]
    diff = np.diff(points, axis =1)
    points_new[1] = points[np.argmin(diff)]
    points_new[2] = points[np.argmax(diff)]
    return points_new
def splitcells(img):
    rows = np.vsplit(img,9)
    boxes = []
    for r in rows:
        cols = np.hsplit(r,9)
        for box in cols:
          boxes.append(box)
    return boxes
black_img = np.zeros((450,450,3), np.uint8)
biggest, maxArea = main_outline(contour)
if biggest.size != 0:
  biggest = reframe(biggest)
  cv2.drawContours(contour_2,biggest,-1, (0,255,0),10)
  pts1 = np.float32(biggest)
  pts2 = np.float32([[0,0],[450,0],[0,450],[450,450]])
  matrix = cv2.getPerspectiveTransform(pts1,pts2)
  imagewrap = cv2.warpPerspective(sudoku_a,matrix,(450,450))
  imagewrap =cv2.cvtColor(imagewrap, cv2.COLOR_BGR2GRAY)
  # plt.figure()
  # plt.imshow(imagewrap)
  # plt.show()

su_puzzle = cv2.imread("sudoku/sudoku_paper.png")
#let's see what we got
# plt.figure()
# plt.imshow(su_puzzle)
# plt.show()

su_contour_1= su_puzzle.copy()
su_contour_2= su_puzzle.copy()
su_contour, hierarchy = cv2.findContours(preprocess(su_puzzle),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(su_contour_1, su_contour,-1,(0,255,0),3)
black_img = np.zeros((450,450,3), np.uint8)
su_biggest, su_maxArea = main_outline(su_contour)
if su_biggest.size != 0:
  su_biggest = reframe(su_biggest)
  cv2.drawContours(su_contour_2,su_biggest,-1, (0,255,0),10)
  su_pts1 = np.float32(su_biggest)
  su_pts2 = np.float32([[0,0],[450,0],[0,450],[450,450]])
  su_matrix = cv2.getPerspectiveTransform(su_pts1,su_pts2)
  su_imagewrap = cv2.warpPerspective(su_puzzle,su_matrix,(450,450))
  su_imagewrap =cv2.cvtColor(su_imagewrap, cv2.COLOR_BGR2GRAY)
  # plt.figure()
  # plt.imshow(su_imagewrap)
  # plt.show()

#[[0 3 0 1 5 2 0 0 0]
#  [0 8 0 0 2 0 0 1 0]
#  [5 0 0 0 0 0 5 0 0]
#  [0 7 0 0 0 0 4 0 0]
#  [2 0 0 4 4 1 0 0 0]
#  [0 0 8 0 0 7 0 1 0]
#  [0 0 1 0 0 0 0 0 4]
#  [0 5 0 0 1 0 0 8 0]
#  [0 0 0 2 0 8 0 4 0]]

sudoku_cell = splitcells(su_imagewrap)
#Let's have alook at the last cell
# plt.figure()
# plt.imshow(sudoku_cell[58])
# plt.show()

def CropCell(cells):
  Cells_croped = []
  for image in cells:
      img = np.array(image)
      img = img[4:46, 6:46]
      img = Image.fromarray(img)
      Cells_croped.append(img)
  return Cells_croped
sudoku_cell_croped= CropCell(sudoku_cell)
#Let's have alook at the last cell
# plt.figure()
# plt.imshow(sudoku_cell_croped[58])
# plt.show()

import tensorflow as tf
from tensorflow import keras
from keras.models import load_model

model = load_model('model/model4.h5')

# Crop the cells from the sudoku grid
sudoku_cell_croped = CropCell(sudoku_cell)

# Initialize the sudoku grid
sudoku_grid = np.zeros((9, 9), dtype=int)

# Iterate through each cell
fig, axs = # plt.subplots(9, 9, figsize=(10, 10))

for i in range(9):
    for j in range(9):
        cell_image = np.array(sudoku_cell_croped[i * 9 + j])  # Convert to numpy array
        # Use a simple thresholding to binarize the image
        _, cell_threshold = cv2.threshold(cell_image, 128, 255, cv2.THRESH_BINARY)
        # Invert the image (black background, white numbers)
        cell_inverted = cv2.bitwise_not(cell_threshold)
        # Find contours in the cell image
        contours, _ = cv2.findContours(cell_inverted, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        # If contours are found, assume the cell contains a number
        if contours:
            # Use the contour area to filter out noise
            contour_area = cv2.contourArea(contours[0])
            if contour_area > 10:  # Adjust the threshold as needed
                # Extract the digit from the cell image
                cell_digit = cv2.resize(cell_inverted, (28, 28))
                cell_digit = cell_digit / 255.0  # Normalize the pixel values
                cell_digit = cell_digit.reshape(28, 28, 1)
                rgb_image = np.concatenate([cell_digit, cell_digit, cell_digit], axis=-1)  # Reshape for model input
                rgb_image_batch = np.expand_dims(rgb_image, axis=0)
                # Predict the digit using the trained model (replace `model` with your trained model)
                images=np.vstack([rgb_image_batch])
                predicted_digit = np.argmax(model.predict(images))
                # print("Type: {}, Size: {}, Data type: {}".format(type(cell_digit), cell_digit.shape, cell_digit.dtype))
                # Store the predicted digit in the sudoku grid
                sudoku_grid[i][j] = predicted_digit
                axs[i, j].imshow(cell_digit.squeeze(),cmap='gray')
                axs[i, j].axis('off')

# Display the sudoku grid
print(sudoku_grid)



from docplex.cp.model import CpoModel

# Given Sudoku puzzle size
N = 9

# Given initial Sudoku configuration (replace ... with actual values)
initial_sudoku = sudoku_grid

# Create CP model
model = CpoModel()

# Define decision variables
X = [[model.integer_var(1, N, f"X[{i+1}][{j+1}]") for j in range(N)] for i in range(N)]

# Add constraints
for i in range(N):
    model.add(model.all_diff([X[i][j] for j in range(N)]))
    model.add(model.all_diff([X[j][i] for j in range(N)]))

for i in range(0, N, 3):
    for j in range(0, N, 3):
        model.add(model.all_diff([X[i+di][j+dj] for di in range(3) for dj in range(3)]))

for i in range(N):
    for j in range(N):
        if initial_sudoku[i][j] != 0:
            model.add(X[i][j] == initial_sudoku[i][j])

# Solve the Sudoku puzzle
solution = model.solve()

# Print the solution
if solution:
  solved_sudoku = []
  for row in X:
    current_row = []
    for cell in row:
        current_row.append(solution.get_value(cell))
    solved_sudoku.append(current_row)

# Convert the solution list into a 2D NumPy array
  solved_sudoku_array = np.array(solved_sudoku)

# Print the solved Sudoku as a NumPy array
  print("The solved Sudoku:")
  print(solved_sudoku_array)
else:
    print("No solution found.")

import numpy as np
import matplotlib.pyplot as # plt
import cv2  # Import OpenCV for drawing functions

def sudoku_to_image(sudoku_array, sudoku_grid):
    # Create a blank image with white background
    image = np.ones((454, 454, 3)) * 255  # White background with outer border

    # Define the dimensions of each cell and the grid thickness
    cell_size = 50
    grid_thickness = 2
    outer_border_thickness = 4  # Thickness of the outer border

    # Draw outer border
    cv2.rectangle(image, (0, 0), (453, 453), (0, 0, 0), outer_border_thickness)

    # Loop through each cell in the Sudoku array
    for i in range(9):
        for j in range(9):
            # Get the value of the cell
            cell_value = sudoku_array[i][j]

            # If the cell value is not zero, write it on the image
            if cell_value != 0:
                # Calculate the position to write the cell value
                x_pos = j * cell_size + 17
                y_pos = i * cell_size + 35

                # Determine the color based on sudoku_grid
                if sudoku_grid[i][j] == cell_value:
                    color = (0, 0, 255)  # Red color for correct cells
                else:
                    color = (0, 0, 0)  # Black color for incorrect cells

                # Write the cell value on the image
                cv2.putText(image, str(cell_value), (x_pos, y_pos), cv2.FONT_HERSHEY_COMPLEX_SMALL, 1.5, color, 2)

    # Draw gridlines
    for i in range(1, 9):
        if i % 3 == 0:
            thickness = 2 * grid_thickness
        else:
            thickness = grid_thickness

        # Draw horizontal grid lines
        cv2.line(image, (0, i * cell_size), (453, i * cell_size), (0, 0, 0), thickness)
        # Draw vertical grid lines
        cv2.line(image, (i * cell_size, 0), (i * cell_size, 453), (0, 0, 0), thickness)

    return image

# Given Sudoku array
sudoku_array =solved_sudoku_array

# Given Sudoku grid
hints_grid = sudoku_grid

# Convert the Sudoku array to an image with borders around each cell
sudoku_image = sudoku_to_image(sudoku_array, hints_grid)

# Display the image using Matplotlib
# plt.imshow(sudoku_image)
# plt.axis('off')
# plt.show()

